# coding: utf-8

"""
    CDR Banking API

    Consumer Data Standards APIs created by the Data Standards Body (DSB), with the Data Standards Chair as the decision maker to meet the needs of the Consumer Data Right

    The version of the OpenAPI document: 1.29.0
    Contact: contact@consumerdatastandards.gov.au
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CommonPAFAddress(BaseModel):
    """
    Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
    """ # noqa: E501
    dpid: Optional[StrictStr] = Field(default=None, description="Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier")
    thoroughfare_number1: Optional[StrictInt] = Field(default=None, description="Thoroughfare number for a property (first number in a property ranged address)", alias="thoroughfareNumber1")
    thoroughfare_number1_suffix: Optional[StrictStr] = Field(default=None, description="Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated", alias="thoroughfareNumber1Suffix")
    thoroughfare_number2: Optional[StrictInt] = Field(default=None, description="Second thoroughfare number (only used if the property has a ranged address eg 23-25)", alias="thoroughfareNumber2")
    thoroughfare_number2_suffix: Optional[StrictStr] = Field(default=None, description="Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated", alias="thoroughfareNumber2Suffix")
    flat_unit_type: Optional[StrictStr] = Field(default=None, description="Type of flat or unit for the address", alias="flatUnitType")
    flat_unit_number: Optional[StrictStr] = Field(default=None, description="Unit number (including suffix, if applicable)", alias="flatUnitNumber")
    floor_level_type: Optional[StrictStr] = Field(default=None, description="Type of floor or level for the address", alias="floorLevelType")
    floor_level_number: Optional[StrictStr] = Field(default=None, description="Floor or level number (including alpha characters)", alias="floorLevelNumber")
    lot_number: Optional[StrictStr] = Field(default=None, description="Allotment number for the address", alias="lotNumber")
    building_name1: Optional[StrictStr] = Field(default=None, description="Building/Property name 1", alias="buildingName1")
    building_name2: Optional[StrictStr] = Field(default=None, description="Building/Property name 2", alias="buildingName2")
    street_name: Optional[StrictStr] = Field(default=None, description="The name of the street", alias="streetName")
    street_type: Optional[StrictStr] = Field(default=None, description="The street type. Valid enumeration defined by Australia Post PAF code file", alias="streetType")
    street_suffix: Optional[StrictStr] = Field(default=None, description="The street type suffix. Valid enumeration defined by Australia Post PAF code file", alias="streetSuffix")
    postal_delivery_type: Optional[StrictStr] = Field(default=None, description="Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file", alias="postalDeliveryType")
    postal_delivery_number: Optional[StrictInt] = Field(default=None, description="Postal delivery number if the address is a postal delivery type", alias="postalDeliveryNumber")
    postal_delivery_number_prefix: Optional[StrictStr] = Field(default=None, description="Postal delivery number prefix related to the postal delivery number", alias="postalDeliveryNumberPrefix")
    postal_delivery_number_suffix: Optional[StrictStr] = Field(default=None, description="Postal delivery number suffix related to the postal delivery number", alias="postalDeliveryNumberSuffix")
    locality_name: StrictStr = Field(description="Full name of locality", alias="localityName")
    postcode: StrictStr = Field(description="Postcode for the locality")
    state: StrictStr = Field(description="State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT")
    __properties: ClassVar[List[str]] = ["dpid", "thoroughfareNumber1", "thoroughfareNumber1Suffix", "thoroughfareNumber2", "thoroughfareNumber2Suffix", "flatUnitType", "flatUnitNumber", "floorLevelType", "floorLevelNumber", "lotNumber", "buildingName1", "buildingName2", "streetName", "streetType", "streetSuffix", "postalDeliveryType", "postalDeliveryNumber", "postalDeliveryNumberPrefix", "postalDeliveryNumberSuffix", "localityName", "postcode", "state"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CommonPAFAddress from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CommonPAFAddress from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "dpid": obj.get("dpid"),
            "thoroughfareNumber1": obj.get("thoroughfareNumber1"),
            "thoroughfareNumber1Suffix": obj.get("thoroughfareNumber1Suffix"),
            "thoroughfareNumber2": obj.get("thoroughfareNumber2"),
            "thoroughfareNumber2Suffix": obj.get("thoroughfareNumber2Suffix"),
            "flatUnitType": obj.get("flatUnitType"),
            "flatUnitNumber": obj.get("flatUnitNumber"),
            "floorLevelType": obj.get("floorLevelType"),
            "floorLevelNumber": obj.get("floorLevelNumber"),
            "lotNumber": obj.get("lotNumber"),
            "buildingName1": obj.get("buildingName1"),
            "buildingName2": obj.get("buildingName2"),
            "streetName": obj.get("streetName"),
            "streetType": obj.get("streetType"),
            "streetSuffix": obj.get("streetSuffix"),
            "postalDeliveryType": obj.get("postalDeliveryType"),
            "postalDeliveryNumber": obj.get("postalDeliveryNumber"),
            "postalDeliveryNumberPrefix": obj.get("postalDeliveryNumberPrefix"),
            "postalDeliveryNumberSuffix": obj.get("postalDeliveryNumberSuffix"),
            "localityName": obj.get("localityName"),
            "postcode": obj.get("postcode"),
            "state": obj.get("state")
        })
        return _obj


