# coding: utf-8

"""
    CDR Banking API

    Consumer Data Standards APIs created by the Data Standards Body (DSB), with the Data Standards Chair as the decision maker to meet the needs of the Consumer Data Right

    The version of the OpenAPI document: 1.29.0
    Contact: contact@consumerdatastandards.gov.au
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, Field, StrictBool, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from au_open_banking_spec.models.banking_transaction_detail_all_of_extended_data import BankingTransactionDetailAllOfExtendedData
from typing import Optional, Set
from typing_extensions import Self

class BankingTransactionDetail(BaseModel):
    """
    BankingTransactionDetail
    """ # noqa: E501
    account_id: StrictStr = Field(description="ID of the account for which transactions are provided", alias="accountId")
    transaction_id: Optional[StrictStr] = Field(default=None, description="A unique ID of the transaction adhering to the standards for ID permanence.  This is mandatory (through hashing if necessary) unless there are specific and justifiable technical reasons why a transaction cannot be uniquely identified for a particular account type. It is mandatory if `isDetailAvailable` is set to true.", alias="transactionId")
    is_detail_available: StrictBool = Field(description="True if extended information is available using the transaction detail end point. False if extended data is not available", alias="isDetailAvailable")
    type: StrictStr = Field(description="The type of the transaction")
    status: StrictStr = Field(description="Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction")
    description: StrictStr = Field(description="The transaction description as applied by the financial institution")
    posting_date_time: Optional[StrictStr] = Field(default=None, description="The time the transaction was posted. This field is Mandatory if the transaction has status POSTED.  This is the time that appears on a standard statement", alias="postingDateTime")
    value_date_time: Optional[StrictStr] = Field(default=None, description="Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry", alias="valueDateTime")
    execution_date_time: Optional[StrictStr] = Field(default=None, description="The time the transaction was executed by the originating customer, if available", alias="executionDateTime")
    amount: StrictStr = Field(description="The value of the transaction. Negative values mean money was outgoing from the account")
    currency: Optional[StrictStr] = Field(default=None, description="The currency for the transaction amount. AUD assumed if not present")
    reference: StrictStr = Field(description="The reference for the transaction provided by the originating institution. Empty string if no data provided")
    merchant_name: Optional[StrictStr] = Field(default=None, description="Name of the merchant for an outgoing payment to a merchant", alias="merchantName")
    merchant_category_code: Optional[StrictStr] = Field(default=None, description="The merchant category code (or MCC) for an outgoing payment to a merchant", alias="merchantCategoryCode")
    biller_code: Optional[StrictStr] = Field(default=None, description="BPAY Biller Code for the transaction (if available)", alias="billerCode")
    biller_name: Optional[StrictStr] = Field(default=None, description="Name of the BPAY biller for the transaction (if available)", alias="billerName")
    crn: Optional[StrictStr] = Field(default=None, description="BPAY CRN for the transaction (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.")
    apca_number: Optional[StrictStr] = Field(default=None, description="6 Digit APCA number for the initiating institution. The field is fixed-width and padded with leading zeros if applicable.", alias="apcaNumber")
    extended_data: BankingTransactionDetailAllOfExtendedData = Field(alias="extendedData")
    __properties: ClassVar[List[str]] = ["accountId", "transactionId", "isDetailAvailable", "type", "status", "description", "postingDateTime", "valueDateTime", "executionDateTime", "amount", "currency", "reference", "merchantName", "merchantCategoryCode", "billerCode", "billerName", "crn", "apcaNumber", "extendedData"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['DIRECT_DEBIT', 'FEE', 'INTEREST_CHARGED', 'INTEREST_PAID', 'OTHER', 'PAYMENT', 'TRANSFER_INCOMING', 'TRANSFER_OUTGOING']):
            raise ValueError("must be one of enum values ('DIRECT_DEBIT', 'FEE', 'INTEREST_CHARGED', 'INTEREST_PAID', 'OTHER', 'PAYMENT', 'TRANSFER_INCOMING', 'TRANSFER_OUTGOING')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['PENDING', 'POSTED']):
            raise ValueError("must be one of enum values ('PENDING', 'POSTED')")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BankingTransactionDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of extended_data
        if self.extended_data:
            _dict['extendedData'] = self.extended_data.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BankingTransactionDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "accountId": obj.get("accountId"),
            "transactionId": obj.get("transactionId"),
            "isDetailAvailable": obj.get("isDetailAvailable"),
            "type": obj.get("type"),
            "status": obj.get("status"),
            "description": obj.get("description"),
            "postingDateTime": obj.get("postingDateTime"),
            "valueDateTime": obj.get("valueDateTime"),
            "executionDateTime": obj.get("executionDateTime"),
            "amount": obj.get("amount"),
            "currency": obj.get("currency"),
            "reference": obj.get("reference"),
            "merchantName": obj.get("merchantName"),
            "merchantCategoryCode": obj.get("merchantCategoryCode"),
            "billerCode": obj.get("billerCode"),
            "billerName": obj.get("billerName"),
            "crn": obj.get("crn"),
            "apcaNumber": obj.get("apcaNumber"),
            "extendedData": BankingTransactionDetailAllOfExtendedData.from_dict(obj["extendedData"]) if obj.get("extendedData") is not None else None
        })
        return _obj


